{"version":3,"sources":["pathfinding visualizer/node/Node.jsx","helpers/helper.jsx","pathfinding visualizer/algorithms/PathFindingAlgorithms.jsx","pathfinding visualizer/PathFinderVisualizer.jsx","App.jsx","index.js"],"names":["Node","this","props","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","algorithms","START_NODE_ROW","START_NODE_COL","handleCheck","node","BFS","state","nodes","animations","queue","backtrackNode","length","current_node","shift","isVisited","push","previousNode","NODES_COLS","NODES_ROWS","backtrack","unshift","PathFinderVisualizer","algorithm","mousePressed","start","finish","setState","getInitialNodes","grid","getNewGridWithWallToggled","stack","pop","DFS","i","j","distance","Math","sqrt","pow","sort","nodeA","nodeB","ASTAR","bfs","dfs","a_star","dijkstra","setTimeout","document","getElementById","classList","add","mouseIsPressed","onClick","begin","window","location","reload","map","currRows","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","createNode","Infinity","newNodes","slice","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.39c6e87b.chunk.js","sourcesContent":["import './Node.scss'\r\n\r\nimport React, { Component } from \"react\";\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp\r\n        } = this.props;\r\n\r\n        const extraClassName = isFinish ?\r\n            'node-finish' : isStart ?\r\n                'node-start' : isWall ?\r\n                    'node-wall' : '';\r\n\r\n        return (\r\n            <div\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n            />\r\n        )\r\n    }\r\n}","export const algorithms = {\r\n    DEFAULT: \"None\",\r\n    DFS: \"DFS\",\r\n    BFS: \"BFS\",\r\n    ASTAR: \"A*\",\r\n    DIJKSTRA: \"Dijkstra\",\r\n}\r\n\r\nexport const START_NODE_ROW = 18;\r\nexport const START_NODE_COL = 29;\r\nexport const FINISH_NODE_ROW = 18;\r\nexport const FINISH_NODE_COL = 69;\r\nexport const NODES_ROWS = 38;\r\nexport const NODES_COLS = 90;","import {\r\n    START_NODE_ROW,\r\n    START_NODE_COL,\r\n    FINISH_NODE_ROW,\r\n    FINISH_NODE_COL,\r\n    NODES_ROWS,\r\n    NODES_COLS,\r\n} from \"../../helpers/helper\";\r\n\r\nconst handleCheck = (node) => {\r\n    return node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL;\r\n}\r\n\r\n// let graph = {}\r\n//\r\n// for (let i = 0; i < NODES_ROWS; i++) {\r\n//     for (let j = 0; j < NODES_COLS; j++) {\r\n//         graph[i * NODES_COLS + j] = nodes[i][j];\r\n//     }\r\n// }\r\nconst sortArrayByDistance = arr => {\r\n    arr.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport const BFS = state => {\r\n    const nodes = state.nodes;\r\n    const animations = [];\r\n\r\n    const queue = [nodes[START_NODE_ROW][START_NODE_COL]];\r\n    let backtrackNode = null;\r\n\r\n    while (queue.length) {\r\n        const current_node = queue[0];\r\n        queue.shift();\r\n\r\n        if (!current_node.isVisited && !current_node.isWall) {\r\n            const row = current_node.row, col = current_node.col;\r\n            animations.push([row, col]);\r\n            current_node.isVisited = true;\r\n\r\n            if (handleCheck(current_node)) {\r\n                backtrackNode = current_node;\r\n                break;\r\n            }\r\n\r\n            if (row > 0) {\r\n                if (!nodes[row - 1][col].isVisited) {\r\n                    nodes[row - 1][col].previousNode = current_node;\r\n                    queue.push(nodes[row - 1][col]);\r\n                }\r\n            }\r\n\r\n            if (col < NODES_COLS - 1) {\r\n                if (!nodes[row][col + 1].isVisited) {\r\n                    nodes[row][col + 1].previousNode = current_node;\r\n                    queue.push(nodes[row][col + 1]);\r\n                }\r\n            }\r\n\r\n            if (row < NODES_ROWS - 1) {\r\n                if (!nodes[row + 1][col].isVisited) {\r\n                    nodes[row + 1][col].previousNode = current_node;\r\n                    queue.push(nodes[row + 1][col]);\r\n                }\r\n            }\r\n\r\n            if (col > 0) {\r\n                if (!nodes[row][col - 1].isVisited) {\r\n                    nodes[row][col - 1].previousNode = current_node;\r\n                    queue.push(nodes[row][col - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const backtrack = [];\r\n\r\n    if (backtrackNode) {\r\n        while (backtrackNode.row !== START_NODE_ROW || backtrackNode.col !== START_NODE_COL) {\r\n            backtrack.unshift([backtrackNode.row, backtrackNode.col]);\r\n            backtrackNode = backtrackNode.previousNode;\r\n        }\r\n    }\r\n\r\n    return [animations, backtrack];\r\n}\r\n\r\nexport const DFS = state => {\r\n    const nodes = state.nodes;\r\n    const animations = [];\r\n\r\n    let stack = [nodes[START_NODE_ROW][START_NODE_COL]];\r\n    let backtrackNode = null;\r\n\r\n    while (stack.length) {\r\n        const current_node = stack.pop();\r\n\r\n        if (!current_node.isVisited && !current_node.isWall) {\r\n            const row = current_node.row, col = current_node.col;\r\n            animations.push([row, col]);\r\n            current_node.isVisited = true;\r\n\r\n            if (handleCheck(current_node)) {\r\n                backtrackNode = current_node;\r\n                break;\r\n            }\r\n\r\n            if (col > 0) {\r\n                if (!nodes[row][col - 1].isVisited) {\r\n                    nodes[row][col - 1].previousNode = current_node;\r\n                    stack.push(nodes[row][col - 1]);\r\n                }\r\n            }\r\n\r\n            if (row < NODES_ROWS - 1) {\r\n                if (!nodes[row + 1][col].isVisited) {\r\n                    nodes[row + 1][col].previousNode = current_node;\r\n                    stack.push(nodes[row + 1][col]);\r\n                }\r\n            }\r\n\r\n            if (col < NODES_COLS - 1) {\r\n                if (!nodes[row][col + 1].isVisited) {\r\n                    nodes[row][col + 1].previousNode = current_node;\r\n                    stack.push(nodes[row][col + 1]);\r\n                }\r\n            }\r\n\r\n            if (row > 0) {\r\n                if (!nodes[row - 1][col].isVisited) {\r\n                    nodes[row - 1][col].previousNode = current_node;\r\n                    stack.push(nodes[row - 1][col]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const backtrack = [];\r\n\r\n    if (backtrackNode) {\r\n        while (backtrackNode.row !== START_NODE_ROW || backtrackNode.col !== START_NODE_COL) {\r\n            backtrack.unshift([backtrackNode.row, backtrackNode.col]);\r\n            backtrackNode = backtrackNode.previousNode;\r\n        }\r\n    }\r\n\r\n    return [animations, backtrack];\r\n}\r\n\r\nexport const ASTAR = state => {\r\n    const nodes = state.nodes;\r\n\r\n    for (let i = 0; i < NODES_ROWS; i++) {\r\n        for (let j = 0; j < NODES_COLS; j++) {\r\n            nodes[i][j].distance = Math.sqrt(Math.pow(i - FINISH_NODE_ROW, 2) + Math.pow(j - FINISH_NODE_COL, 2));\r\n        }\r\n    }\r\n\r\n    const animations = []\r\n\r\n    let stack = [nodes[START_NODE_ROW][START_NODE_COL]];\r\n    let backtrackNode = null;\r\n\r\n    while (stack.length) {\r\n        const current_node = stack.shift();\r\n\r\n        if (!current_node.isVisited && !current_node.isWall) {\r\n            const row = current_node.row, col = current_node.col;\r\n            animations.push([row, col]);\r\n            current_node.isVisited = true;\r\n\r\n            if (handleCheck(current_node)) {\r\n                backtrackNode = current_node;\r\n                break;\r\n            }\r\n\r\n            if (col > 0) {\r\n                if (!nodes[row][col - 1].isVisited) {\r\n                    nodes[row][col - 1].previousNode = current_node;\r\n                    stack.push(nodes[row][col - 1]);\r\n                }\r\n            }\r\n\r\n            if (row < NODES_ROWS - 1) {\r\n                if (!nodes[row + 1][col].isVisited) {\r\n                    nodes[row + 1][col].previousNode = current_node;\r\n                    stack.push(nodes[row + 1][col]);\r\n                }\r\n            }\r\n\r\n            if (col < NODES_COLS - 1) {\r\n                if (!nodes[row][col + 1].isVisited) {\r\n                    nodes[row][col + 1].previousNode = current_node;\r\n                    stack.push(nodes[row][col + 1]);\r\n                }\r\n            }\r\n\r\n            if (row > 0) {\r\n                if (!nodes[row - 1][col].isVisited) {\r\n                    nodes[row - 1][col].previousNode = current_node;\r\n                    stack.push(nodes[row - 1][col]);\r\n                }\r\n            }\r\n        }\r\n\r\n        sortArrayByDistance(stack);\r\n    }\r\n\r\n    const backtrack = [];\r\n\r\n    if (backtrackNode) {\r\n        while (backtrackNode.row !== START_NODE_ROW || backtrackNode.col !== START_NODE_COL) {\r\n            backtrack.unshift([backtrackNode.row, backtrackNode.col]);\r\n            backtrackNode = backtrackNode.previousNode;\r\n        }\r\n    }\r\n\r\n    return [animations, backtrack];\r\n}\r\n","import './PathFindingVisualizer.scss';\r\n\r\nimport Node from \"./node/Node\"\r\nimport React, { Component } from \"react\";\r\nimport { BFS, DFS, ASTAR } from \"./algorithms/PathFindingAlgorithms\";\r\nimport {\r\n    algorithms,\r\n    START_NODE_ROW,\r\n    START_NODE_COL,\r\n    FINISH_NODE_ROW,\r\n    FINISH_NODE_COL,\r\n    NODES_ROWS,\r\n    NODES_COLS,\r\n} from \"../helpers/helper\"\r\n\r\nexport default class PathFinderVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            nodes: [],\r\n            algorithm: algorithms.DEFAULT,\r\n            mousePressed: false,\r\n            start: [START_NODE_ROW, START_NODE_COL],\r\n            finish: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.setState({nodes: getInitialNodes()});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        this.setState({\r\n            grid: getNewGridWithWallToggled(this.state.nodes, row, col),\r\n            mousePressed: true,\r\n        })\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (this.state.mousePressed) {\r\n            this.setState({\r\n                grid: getNewGridWithWallToggled(this.state.nodes, row, col),\r\n            });\r\n        }\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({\r\n            mousePressed: false,\r\n        });\r\n    }\r\n\r\n    bfs() {\r\n        const animations = BFS(this.state);\r\n\r\n        return animations;\r\n    }\r\n\r\n    dfs() {\r\n        const animations = DFS(this.state);\r\n\r\n        return animations;\r\n    }\r\n\r\n    a_star() {\r\n        const animations = ASTAR(this.state);\r\n\r\n        return animations;\r\n    }\r\n\r\n    djikstra() {\r\n        const animations = BFS(this.state);\r\n\r\n        return animations;\r\n    }\r\n\r\n    begin() {\r\n        let animations = [];\r\n\r\n        switch (this.state.algorithm) {\r\n            case algorithms.BFS:\r\n                animations = this.bfs();\r\n                break;\r\n            case algorithms.DFS:\r\n                animations = this.dfs();\r\n                break;\r\n            case algorithms.ASTAR:\r\n                animations = this.a_star();\r\n                break;\r\n            case algorithms.DIJKSTRA:\r\n                animations = this.dijkstra();\r\n                break;\r\n            case algorithms.DEFAULT:\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        for (let i = 0; i < animations[0].length; i++) {\r\n            setTimeout(() => {\r\n                const [ row, col ] = animations[0][i];\r\n                document.getElementById(`node-${row}-${col}`).classList.add(\"node-visited\");\r\n            }, i * 10);\r\n        }\r\n\r\n        for (let i = 0; i < animations[1].length; i++) {\r\n            setTimeout(() => {\r\n                const [ row, col ] = animations[1][i];\r\n                document.getElementById(`node-${row}-${col}`).classList.add(\"node-path\");\r\n            }, (animations[0].length * 10) + i * 10);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const { nodes, mouseIsPressed } = this.state;\r\n\r\n        return (\r\n            <div className=\"visualizer\">\r\n                <div className=\"buttons\">\r\n                    <button\r\n                        onClick={() => {\r\n                            this.setState({algorithm: algorithms.BFS});\r\n                        }}\r\n                    >\r\n                        Breadth First Search\r\n                    </button>\r\n                    <button\r\n                        onClick={() => {\r\n                            this.setState({algorithm: algorithms.DFS});\r\n                        }}\r\n                    >\r\n                        Depth First Search\r\n                    </button>\r\n                    <button\r\n                        onClick={() => {\r\n                            this.setState({algorithm: algorithms.ASTAR});\r\n                        }}\r\n                    >\r\n                        A*\r\n                    </button>\r\n                    <button\r\n                        onClick={() => {\r\n                            this.setState({algorithm: algorithms.DIJKSTRA});\r\n                        }}\r\n                    >\r\n                        Dijkstra\r\n                    </button>\r\n                </div>\r\n                <div className=\"buttons\">\r\n                    <button\r\n                        onClick={() => {\r\n                            this.begin();\r\n                        }}\r\n                    >\r\n                        Begin\r\n                    </button>\r\n                    <button\r\n                        onClick={() =>  window.location.reload(false)}\r\n                    >\r\n                        Reset\r\n                    </button>\r\n                </div>\r\n                <div className=\"grid\">\r\n                    {nodes.map((currRows, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {currRows.map((node, nodeIdx) => {\r\n                                    const { isStart, isFinish, isVisited, isWall } = node;\r\n\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={rowIdx}\r\n                                            col={nodeIdx}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isVisited={isVisited}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(rowIdx, nodeIdx) => {\r\n                                                this.handleMouseDown(rowIdx, nodeIdx);\r\n                                            }}\r\n                                            onMouseEnter={(rowIdx, nodeIdx) => {\r\n                                                this.handleMouseEnter(rowIdx, nodeIdx);\r\n                                            }}\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst getInitialNodes = () => {\r\n    const nodes = [];\r\n\r\n    for (let i = 0; i < NODES_ROWS; i++) {\r\n        const row = [];\r\n\r\n        for (let j = 0; j < NODES_COLS; j++) {\r\n            row.push(createNode(i, j));\r\n        }\r\n\r\n        nodes.push(row);\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nconst createNode = (row, col) => {\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n    }\r\n}\r\n\r\nconst getNewGridWithWallToggled = (nodes, row, col) => {\r\n    const newNodes = nodes.slice();\r\n    const node = newNodes[row][col];\r\n    newNodes[row][col] = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n\r\n    return newNodes;\r\n};","import './App.scss';\nimport PathFinderVisualizer from \"./pathfinding visualizer/PathFinderVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <PathFinderVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}